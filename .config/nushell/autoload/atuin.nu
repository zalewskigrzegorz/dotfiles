# Atuin - Enhanced shell history
# Provides synchronized and searchable shell history across devices
# Configuration is handled in ~/.config/atuin/config.toml

# Source Atuin init generated by Atuin itself
source ~/.local/share/atuin/init.nu

# Fix for Nushell 0.108+ keybinding issue
# The executehostcommand doesn't properly handle multi-line commands returned by _atuin_search_cmd.
# We create wrapper functions that can be called directly by executehostcommand.

# Wrapper functions that can be called by executehostcommand
# These functions execute the atuin search commands directly
export def "atuin-search-ctrl-r" [] {
    with-env { ATUIN_LOG: error, ATUIN_QUERY: (commandline), ATUIN_SHELL: nu } {
        let output = (run-external atuin search "--interactive" e>| str trim)
        if ($output | str starts-with "__atuin_accept__:") {
            commandline edit --accept ($output | str replace "__atuin_accept__:" "")
        } else {
            commandline edit $output
        }
    }
}

export def "atuin-search-up" [] {
    with-env { ATUIN_LOG: error, ATUIN_QUERY: (commandline), ATUIN_SHELL: nu } {
        let output = (run-external atuin search "--shell-up-key-binding" "--interactive" e>| str trim)
        if ($output | str starts-with "__atuin_accept__:") {
            commandline edit --accept ($output | str replace "__atuin_accept__:" "")
        } else {
            commandline edit $output
        }
    }
}

# Patch the keybindings and pre_execution hook to prevent wrapper functions from being recorded
export-env {
    # Remove existing atuin keybindings
    # Fix: Apply optional chaining to each segment of nested property access
    let existing_keybindings = ($env.config?.keybindings? | default [])
    let filtered_keybindings = ($existing_keybindings | where {|kb| 
        let name = ($kb.name? | default "")
        let modifier = ($kb.modifier? | default "")
        let keycode = ($kb.keycode? | default "")
        # Remove the broken atuin keybindings
        not (
            ($name == "atuin") and (
                (($modifier == "control") and ($keycode == "char_r")) or
                (($modifier == "none") and ($keycode == "up"))
            )
        )
    })
    
    # Add fixed keybindings using our wrapper functions
    # Fix: Use optional chaining to handle missing config
    $env.config = (
        $env.config?
        | default {}
        | upsert keybindings (
            $filtered_keybindings
            | append [
                {
                    name: atuin_search_ctrl_r
                    modifier: control
                    keycode: char_r
                    mode: [emacs, vi_normal, vi_insert]
                    event: { 
                        send: executehostcommand
                        cmd: "atuin-search-ctrl-r"
                    }
                }
                {
                    name: atuin_search_up
                    modifier: none
                    keycode: up
                    mode: [emacs, vi_normal, vi_insert]
                    event: {
                        until: [
                            {send: menuup}
                            {
                                send: executehostcommand
                                cmd: "atuin-search-up"
                            }
                        ]
                    }
                }
            ]
        )
    )
    
    # Patch the pre_execution hook to skip recording our wrapper functions
    # Get the existing pre_execution hooks
    # Fix: Apply optional chaining to each segment of nested property access
    let existing_pre_execution = ($env.config?.hooks?.pre_execution? | default [])
    
    # Create a wrapper that checks for our function names before calling the original hook
    # Fix: Create a new immutable variable in each iteration to avoid closure capture issue
    let patched_pre_execution = ($existing_pre_execution | each {|hook|
        let current_hook = $hook  # Capture the current hook value in a new immutable variable
        {||
            # Check if commandline contains our wrapper function names
            let cmd = (commandline)
            if ($cmd | str contains "atuin-search-ctrl-r") or ($cmd | str contains "atuin-search-up") {
                # Skip history recording for our wrapper functions
                return
            }
            # Otherwise, call the original hook
            do $current_hook  # Use the captured value instead of the loop variable
        }
    })
    
    # Update the hooks with our patched version
    # Fix: Use optional chaining and provide defaults for missing nested properties
    # Read hooks before modifying config to avoid referencing stale values
    let existing_hooks = ($env.config?.hooks? | default {})
    $env.config = (
        $env.config?
        | default {}
        | upsert hooks (
            $existing_hooks
            | upsert pre_execution $patched_pre_execution
        )
    )
}
